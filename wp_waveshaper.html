<!-- Waveshaper • Elementor embed-ready snippet (fixed amp=1, sr=48k) -->
<style>
  /* === Scoped theme tokens (apply only inside .kh-waveshaper) === */
  .kh-waveshaper{ --bg:#0b0f18; --panel:#121829; --ink:#d9e1ff; --muted:#92a1c6; --accent:#44e0ff; --accent-2:#7ef7cf; --grid:#23304d; --good:#1ee0a1; --warn:#ffb454; --hair:#223055; }
  .kh-waveshaper{ color:var(--ink); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"; }
  .kh-waveshaper *{ box-sizing:border-box }

  /* Header */
  .kh-waveshaper .kh-head{ padding:16px clamp(12px, 3vw, 28px); border:1px solid #16203a; border-radius:14px; background: var(--panel); margin-bottom:14px }
  .kh-waveshaper .kh-head h2{ margin:0; font-size:clamp(18px,2.2vw,28px) }
  .kh-waveshaper .kh-head p{ margin:.35rem 0 0; color:var(--muted); font-size:14px }

  /* Layout */
  .kh-waveshaper .kh-grid{ display:grid; gap:20px; grid-template-columns: 1fr 320px; grid-template-areas: "plots controls"; align-items:start }
  @media (max-width: 980px){ .kh-waveshaper .kh-grid{ grid-template-columns:1fr; grid-template-areas: "controls" "plots" } }

  /* Cards */
  .kh-waveshaper .kh-card{ background: var(--panel); border: 1px solid #1a2340; border-radius: 16px; box-shadow: 0 6px 24px rgba(0,0,0,.35); margin: 0; padding: 6px }
  .kh-waveshaper .kh-card h3{ margin: 6px 8px 10px; font-size: 14px; font-weight: 600; color:#e7edff; letter-spacing:.2px }

  .kh-waveshaper .kh-plots{ grid-area:plots; display:grid; gap:20px }
  .kh-waveshaper .kh-controls{ grid-area:controls; position: sticky; top: 8px }

  /* Controls */
  .kh-waveshaper label{ font-size: 13px; color: var(--muted); display:block; margin: 8px 0 6px }
  .kh-waveshaper .kh-row{ margin-bottom: 14px }
  .kh-waveshaper select{
    appearance:none; -webkit-appearance:none; -moz-appearance:none; width:100%;
    background:#0f1527 url("data:image/svg+xml;utf8,<svg fill='%23cfe0ff' height='14' viewBox='0 0 20 20' width='14' xmlns='http://www.w3.org/2000/svg'><path d='M5.25 7.5l4.75 4.75 4.75-4.75' /></svg>") no-repeat right 12px center; background-size:14px 14px;
    color:var(--ink); border:1px solid var(--hair); border-radius:10px; padding:10px 38px 10px 12px; font-size:14px; outline:none;
  }
  .kh-waveshaper select:focus{ border-color: var(--accent); box-shadow: 0 0 0 3px rgba(68,224,255,.18) }
  .kh-waveshaper .kh-range{ display:flex; align-items:center; gap:10px }
  .kh-waveshaper input[type=range]{ width:100% }
  .kh-waveshaper .kh-badge{ font-feature-settings:"tnum" 1; font-variant-numeric:tabular-nums; background:#0f1527; border:1px solid #223055; color:#cfe0ff; padding:6px 10px; border-radius:10px; font-size:12px; min-width:62px; text-align:center }
  .kh-waveshaper .kh-hint{ font-size:11px; color:var(--muted) }

  /* Legend chips */
  .kh-waveshaper .kh-legend{ display:flex; gap:10px; align-items:center; color:var(--muted); font-size:12px; padding: 0 8px 6px }
  .kh-waveshaper .kh-chip{ display:inline-flex; align-items:center; gap:6px; padding:6px 10px; background:#0f1527; border:1px solid #223055; border-radius:999px }
  .kh-waveshaper .kh-chip .sw{ width:12px; height:12px; border-radius:3px; background:var(--accent) }
  .kh-waveshaper .kh-chip .sw.alt{ background:var(--accent-2) }
  .kh-waveshaper .kh-chip .sw.warn{ background:var(--warn) }

  /* Canvases */
  .kh-waveshaper canvas{ width:100%; height: 220px; display:block; border-radius:10px; background:black }
</style>

<div class="kh-waveshaper">
  <div class="kh-head">
    <h2>Waveshaper</h2>
    <p>Amplitude fixed at 1.0, sample rate fixed at 48 kHz.</p>
  </div>

  <div class="kh-grid">
    <div class="kh-plots">
      <div class="kh-card">
        <h3>Original waveform</h3>
        <div class="kh-legend"><span class="kh-chip"><span class="sw"></span> input</span></div>
        <canvas data-kh-canvas="timeA"></canvas>
      </div>
      <div class="kh-card">
        <h3>Waveshaped waveform</h3>
        <div class="kh-legend"><span class="kh-chip"><span class="sw alt"></span> output</span></div>
        <canvas data-kh-canvas="timeB"></canvas>
      </div>
      <div class="kh-card">
        <h3>Spectrum (waveshaped)</h3>
        <div class="kh-legend">
          <span class="kh-chip"><span class="sw"></span> magnitude</span>
          <span class="kh-chip"><span class="sw warn"></span> ideal > Nyquist</span>
        </div>
        <canvas data-kh-canvas="spec"></canvas>
      </div>
    </div>

    <div class="kh-card kh-controls">
      <h3>Controls</h3>

      <div class="kh-row">
        <label>Waveform</label>
        <select data-kh="wave">
          <option value="sine">Sine</option>
          <option value="saw">Saw</option>
          <option value="triangle">Triangle</option>
          <option value="square">Square</option>
        </select>
      </div>

      <div class="kh-row">
        <label>Frequency</label>
        <div class="kh-range">
          <input data-kh="freq" type="range" min="110" max="10000" step="1" value="1000" />
          <div class="kh-badge"><span data-kh="freqVal">1000</span> Hz</div>
        </div>
      </div>

      <div class="kh-row">
        <label>Waveshaper</label>
        <select data-kh="shaper">
          <option value="tanh" selected>tanh (soft saturation)</option>
          <option value="tanh_asym">tanh (asym, even harmonics)</option>
          <option value="atan">atan (soft saturation)</option>
          <option value="cubic">cubic (soft clip)</option>
          <option value="hard">hard clip</option>
          <option value="sinefold">sine fold</option>
          <option value="none">none (bypass)</option>
        </select>
      </div>

      <div class="kh-row">
        <label>Drive</label>
        <div class="kh-range">
          <input data-kh="drive" type="range" min="0.1" max="10" step="0.1" value="0.1" />
          <div class="kh-badge"><span data-kh="driveVal">0.1</span>×</div>
        </div>
      </div>

      <div class="kh-row" data-kh="skewCtl" style="display:none">
        <label>Asymmetry</label>
        <div class="kh-range">
          <input data-kh="skew" type="range" min="0" max="0.9" step="0.01" value="0.20" />
          <div class="kh-badge"><span data-kh="skewVal">0.20</span></div>
        </div>
      </div>

      <div class="kh-row" data-kh="clipCtl" style="display:none">
        <label>Clip threshold</label>
        <div class="kh-range">
          <input data-kh="clip" type="range" min="0.2" max="1.0" step="0.01" value="0.8" />
          <div class="kh-badge"><span data-kh="clipVal">0.80</span></div>
        </div>
      </div>

      <div class="kh-row">
        <label>Spectrum floor</label>
        <div class="kh-range">
          <input data-kh="dbfloor" type="range" min="-100" max="-20" step="1" value="-40" />
          <div class="kh-badge"><span data-kh="dbfloorVal">-40</span> dB</div>
        </div>
      </div>

      <!-- Removed: Amplitude, Sample rate, Cycles shown, FFT size, Window -->
      <div class="kh-row kh-hint">Spectrum domain is fixed to 10 Hz → 200 kHz. Red dashed line marks Nyquist (24 kHz @ 48 kHz SR). Orange overlay shows ideal > Nyquist extension.</div>
    </div>
  </div>
</div>

<script>
(function(){
  function init(root){
    if(!root) return;
    // ===== Utilities =====
    const qs = (s) => root.querySelector(s);
    const clamp = (v,a,b)=> Math.min(b, Math.max(a,v));
    const dB = (x)=> 20*Math.log10(x);
    const css = getComputedStyle(root);

    // Fixed params (removed controls)
    const A_FIXED = 1.0;          // amplitude
    const SR_FIXED = 48000;       // sample rate (Hz)
    const CYCLES_DEFAULT = 4;     // previously "Cycles shown"
    const FFTLEN_DEFAULT = 32768; // previously "FFT size" (selected)
    const WINTYPE_DEFAULT = 'hann';

    // UI elements
    const els = {
      wave: qs('[data-kh="wave"]'),
      freq: qs('[data-kh="freq"]'), freqVal: qs('[data-kh="freqVal"]'),
      shaper: qs('[data-kh="shaper"]'),
      drive: qs('[data-kh="drive"]'), driveVal: qs('[data-kh="driveVal"]'),
      clipCtl: qs('[data-kh="clipCtl"]'),
      clip: qs('[data-kh="clip"]'), clipVal: qs('[data-kh="clipVal"]'),
      skewCtl: qs('[data-kh="skewCtl"]'),
      skew: qs('[data-kh="skew"]'), skewVal: qs('[data-kh="skewVal"]'),
      dbfloor: qs('[data-kh="dbfloor"]'), dbfloorVal: qs('[data-kh="dbfloorVal"]'),
      timeA: qs('canvas[data-kh-canvas="timeA"]'),
      timeB: qs('canvas[data-kh-canvas="timeB"]'),
      spec:  qs('canvas[data-kh-canvas="spec"]'),
    };

    // Plot helpers
    function clearPlot(ctx,w,h){
      ctx.fillStyle = css.getPropertyValue('--panel');
      ctx.fillRect(0,0,w,h);
      const grid = css.getPropertyValue('--grid');
      ctx.strokeStyle = grid; ctx.lineWidth = 1; ctx.beginPath();
      const vSteps=6, hSteps=10;
      for(let i=1;i<vSteps;i++){ const y=h*i/vSteps; ctx.moveTo(0,y); ctx.lineTo(w,y); }
      for(let i=1;i<hSteps;i++){ const x=w*i/hSteps; ctx.moveTo(x,0); ctx.lineTo(x,h); }
      ctx.stroke();
    }
    function drawSignal(canvas, data, colorCSS, zeroLine=true){
      const ctx = canvas.getContext('2d'); const w=canvas.width, h=canvas.height;
      clearPlot(ctx,w,h);
      if(zeroLine){ ctx.strokeStyle = '#2a3961'; ctx.lineWidth=1.2; ctx.beginPath(); const zy=Math.round(h*0.5)+.5; ctx.moveTo(0,zy); ctx.lineTo(w,zy); ctx.stroke(); }
      ctx.lineWidth=2.0; ctx.strokeStyle=colorCSS; ctx.beginPath();
      for(let i=0;i<data.length;i++){
        const x = i/(data.length-1) * (w-20) + 10;
        const y = (1 - (data[i]*0.5 + 0.5))*(h-20) + 10;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
    }

    // ===== Log-spectrum drawing (fixed 10..200 kHz, Nyquist line, max-hold per pixel, ideal overlay) =====
    function drawSpectrum(canvas, magsDB, sampleRate, ideal){
      const ctx = canvas.getContext('2d'); const W=canvas.width, H=canvas.height;

      const panelCol = css.getPropertyValue('--panel');
      const gridCol  = css.getPropertyValue('--grid');
      const inkCol   = '#9db1de';

      const padL=10, padR=10, padT=8, padB=24; const plotW=W-padL-padR, plotH=H-padT-padB;
      ctx.clearRect(0,0,W,H); ctx.fillStyle=panelCol; ctx.fillRect(0,0,W,H);

      const floor = parseFloat(els.dbfloor.value); const ceil = 0; const nyq = sampleRate*0.5; const fmin=10; const fmax=200000; const logLo=Math.log10(fmin); const logHi=Math.log10(fmax);
      const logX = (f)=> padL + ((Math.log10(f) - logLo)/(logHi-logLo))*plotW;
      const dbToY = (d)=> padT + (1 - (d - floor)/(ceil - floor)) * plotH;

      // dB grid
      ctx.save(); ctx.strokeStyle=gridCol; ctx.lineWidth=1; ctx.globalAlpha=.6; ctx.beginPath();
      for(let d=-140; d<=0; d+=20){ if(d<floor||d>0) continue; const y=Math.round(dbToY(d))+.5; ctx.moveTo(padL,y); ctx.lineTo(W-padR,y); }
      ctx.stroke(); ctx.restore();

      // Log freq grid
      const majors=[100,1000,10000,100000]; const minor=[]; const minExp=Math.floor(Math.log10(fmin)); const maxExp=Math.ceil(Math.log10(fmax));
      for(let e=minExp;e<=maxExp;e++){ const dec=Math.pow(10,e); for(let m=1;m<10;m++){ const f=m*dec; if(f>=fmin&&f<=fmax && !majors.includes(f)) minor.push(f); } }

      ctx.save(); ctx.strokeStyle=gridCol; ctx.globalAlpha=.35; ctx.lineWidth=1; ctx.beginPath();
      for(const f of minor){ const x=Math.round(logX(f))+.5; ctx.moveTo(x,padT); ctx.lineTo(x,H-padB); }
      ctx.stroke(); ctx.restore();

      ctx.save(); ctx.strokeStyle=gridCol; ctx.globalAlpha=.8; ctx.lineWidth=1.5; ctx.beginPath();
      for(const f of majors){ if(f<fmin||f>fmax) continue; const x=Math.round(logX(f))+.5; ctx.moveTo(x,padT); ctx.lineTo(x,H-padB); }
      ctx.stroke(); ctx.restore();

      // Nyquist dashed line
      if(nyq>=fmin && nyq<=fmax){ ctx.save(); ctx.strokeStyle = '#ff5e5e'; ctx.setLineDash([6,4]); ctx.lineWidth=1.5; const xN=Math.round(logX(nyq))+.5; ctx.beginPath(); ctx.moveTo(xN,padT); ctx.lineTo(xN,H-padB); ctx.stroke(); ctx.restore(); }

      // Main spectrum (cyan), max-hold per pixel below Nyquist
      const N2=magsDB.length; ctx.save(); ctx.strokeStyle=css.getPropertyValue('--accent'); ctx.lineWidth=1.6; ctx.beginPath(); let first=true;
      for(let x=padL; x<=W-padR; x++){
        const fL=Math.pow(10, logLo + ((x - padL - .5)/plotW)*(logHi-logLo));
        const fR=Math.pow(10, logLo + ((x - padL + .5)/plotW)*(logHi-logLo));
        const spanMin=Math.max(fmin, Math.min(fL,fR)); const spanMax=Math.min(fmax, Math.max(fL,fR));
        let peakDB=floor; // default beyond Nyquist
        if(spanMin<=nyq){
          const lo=spanMin; const hi=Math.min(spanMax, nyq);
          let kL=Math.floor((lo/nyq)*(N2-1)); let kR=Math.ceil((hi/nyq)*(N2-1));
          if(kR<kL){const t=kL;kL=kR;kR=t;} kL=Math.max(0,Math.min(N2-1,kL)); kR=Math.max(0,Math.min(N2-1,kR));
          if(kR>=kL){ peakDB=-300; for(let kk=kL; kk<=kR; kk++){ if(magsDB[kk]>peakDB) peakDB=magsDB[kk]; } }
        }
        const yy = Math.min(H-padB, Math.max(padT, dbToY(peakDB)));
        if(first){ ctx.moveTo(x,yy); first=false; } else { ctx.lineTo(x,yy); }
      }
      ctx.stroke(); ctx.restore();

      // Ideal overlay beyond Nyquist (orange), from oversampled analysis
      if(ideal && ideal.magsDB && ideal.magsDB.length>1){
        const magsHi=ideal.magsDB; const hiSR=ideal.sampleRate; const hiNyq=hiSR*.5; const N2h=magsHi.length;
        ctx.save(); ctx.strokeStyle=css.getPropertyValue('--warn'); ctx.lineWidth=1.2; ctx.beginPath(); let started=false;
        for(let x=padL; x<=W-padR; x++){
          const fL=Math.pow(10, logLo + ((x - padL - .5)/plotW)*(logHi-logLo));
          const fR=Math.pow(10, logLo + ((x - padL + .5)/plotW)*(logHi-logLo));
          const lo=Math.max(nyq, Math.min(fL,fR)); const hi=Math.min(hiNyq, Math.max(fL,fR));
          if(hi<=lo){ started=false; continue; }
          let kL=Math.floor((lo/hiNyq)*(N2h-1)); let kR=Math.ceil((hi/hiNyq)*(N2h-1));
          if(kR<kL){const t=kL;kL=kR;kR=t;} kL=Math.max(0,Math.min(N2h-1,kL)); kR=Math.max(0,Math.min(N2h-1,kR));
          let peak=-300; for(let kk=kL; kk<=kR; kk++){ if(magsHi[kk]>peak) peak=magsHi[kk]; }
          const yy=Math.min(H-padB, Math.max(padT, dbToY(peak)));
          if(!started){ ctx.moveTo(x,yy); started=true; } else { ctx.lineTo(x,yy); }
        }
        ctx.stroke(); ctx.restore();
      }

      // Labels (major freq bottom)
      ctx.fillStyle=inkCol; ctx.font='12px ui-sans-serif, system-ui'; ctx.textAlign='center'; ctx.textBaseline='alphabetic';
      for(const f of [100,1000,10000,100000]){ if(f<10||f>200000) continue; const x=logX(f); const label=(f>=1000? (f/1000).toFixed(0)+'k' : ''+f); ctx.fillText(label, x, H-6); }
    }

    // ===== Signal & shaping =====
    function genWave(type, freq, amp, sampleRate, length){
      const out = new Float64Array(length);
      const w = 2*Math.PI*freq/sampleRate;

      for (let n = 0; n < length; n++) {
        const t = n / sampleRate;
        let v = 0;

        switch (type) {
          case 'sine':
            v = Math.sin(w*n);
            break;

          case 'square': {
              v = Math.sign(Math.sin(w*n));
              break;
          }

          case 'saw':
            v = 2 * ((freq * t) % 1) - 1;
            break;

          case 'triangle':
            v = (2/Math.PI) * Math.asin(Math.sin(w*n));
            break;

          default:
            v = Math.sin(w*n);
        }

        out[n] = amp * v;
      }
      return out;
    }

    function shapeSample(x,type,drive,clipTh,skew){
      const d=drive;
      switch(type){
        case 'tanh': return Math.tanh(d*x)/Math.tanh(Math.max(1e-6,d));
        case 'tanh_asym': {
          const s = clamp(isFinite(skew)?skew:0, 0, 0.9); // 0..0.9 bias
          const dp = d*(1+s), dn = d*(1-s);
          const pos = Math.tanh(dp*x)/Math.tanh(Math.max(1e-6,dp));
          const neg = Math.tanh(dn*x)/Math.tanh(Math.max(1e-6,dn));
          return x >= 0 ? pos : neg;
        }
        case 'atan': return Math.atan(d*x)/Math.atan(Math.max(1e-6,d));
        case 'cubic':{ const y=x*d; const soft=y-(y*y*y)/3; return clamp(soft,-1,1);}
        case 'hard':{ const y=x*d; const th=Math.max(0.0001,clipTh); return clamp(y,-th,th)/th;}
        case 'sinefold': return Math.sin(d*x);
        case 'none': default: return x;
      }
    }
    function applyShaper(buf,type,drive,clipTh,skew){
      const out=new Float64Array(buf.length);
      for(let i=0;i<buf.length;i++) out[i]=shapeSample(buf[i],type,drive,clipTh,skew);
      return out;
    }

    // ===== FFT =====
    function nextPow2(v){ v--; v|=v>>1; v|=v>>2; v|=v>>4; v|=v>>8; v|=v>>16; v++; return v; }
    function hannWindow(N){ const w=new Float64Array(N); for(let n=0;n<N;n++) w[n]=0.5*(1-Math.cos(2*Math.PI*n/(N-1))); return w; }
    function blackmanWindow(N){ const w=new Float64Array(N); const a0=0.42,a1=0.5,a2=0.08; for(let n=0;n<N;n++){ const ph=2*Math.PI*n/(N-1); w[n]=a0 - a1*Math.cos(ph) + a2*Math.cos(2*ph);} return w; }
    function blackmanHarrisWindow(N){ const w=new Float64Array(N); const a0=0.35875,a1=0.48829,a2=0.14128,a3=0.01168; for(let n=0;n<N;n++){ const ph=2*Math.PI*n/(N-1); w[n]=a0 - a1*Math.cos(ph) + a2*Math.cos(2*ph) - a3*Math.cos(3*ph);} return w; }
    function rectWindow(N){ const w=new Float64Array(N); for(let n=0;n<N;n++) w[n]=1; return w; }
    function makeWindow(type,N){
      switch((type||'hann').toLowerCase()){
        case 'rect': return rectWindow(N);
        case 'blackman': return blackmanWindow(N);
        case 'blackmanharris': return blackmanHarrisWindow(N);
        default: return hannWindow(N);
      }
    }
    function fft(real, imag){
      const n = real.length;

      for (let i = 1, j = 0; i < n; i++) {
        let bit = n >> 1;
        for (; j & bit; bit >>= 1) j ^= bit;
        j ^= bit;
        if (i < j) {
          let tr = real[i]; real[i] = real[j]; real[j] = tr;
          let ti = imag[i]; imag[i] = imag[j]; imag[j] = ti;
        }
      }

      for (let len = 2; len <= n; len <<= 1) {
        const ang = -2 * Math.PI / len;
        const wlenCos = Math.cos(ang), wlenSin = Math.sin(ang);

        for (let i = 0; i < n; i += len) {
          let wcos = 1, wsin = 0;
          for (let j = 0; j < (len >> 1); j++) {
            const uRe = real[i + j], uIm = imag[i + j];
            const vRe = real[i + j + (len >> 1)] * wcos - imag[i + j + (len >> 1)] * wsin;
            const vIm = real[i + j + (len >> 1)] * wsin + imag[i + j + (len >> 1)] * wcos;

            real[i + j]                 = uRe + vRe;
            imag[i + j]                 = uIm + vIm;
            real[i + j + (len >> 1)]    = uRe - vRe;
            imag[i + j + (len >> 1)]    = uIm - vIm;

            const nwcos = wcos * wlenCos - wsin * wlenSin;
            const nwsin = wcos * wlenSin + wsin * wlenCos;
            wcos = nwcos; wsin = nwsin;
          }
        }
      }
    }
    function spectrumDB(signal, sampleRate, windowType='hann'){
      const N=nextPow2(signal.length); const re=new Float64Array(N), im=new Float64Array(N);
      const win=makeWindow(windowType, signal.length);
      for(let i=0;i<signal.length;i++) re[i]=signal[i]*win[i];
      for(let i=signal.length;i<N;i++) re[i]=0;
      fft(re,im);
      const n2=N>>1; const mags=new Float64Array(n2); let maxMag=1e-12;
      for(let k=0;k<n2;k++){ const m=Math.hypot(re[k], im[k])/(N/2); mags[k]=m; if(m>maxMag) maxMag=m; }
      const magsDB=new Float64Array(n2);
      for(let k=0;k<n2;k++) magsDB[k]=clamp(dB(mags[k]/maxMag), -300, 0);
      return magsDB;
    }
    function computeIdealOverlay(sampleRate, fftLen, type, f, A, sh, drv, th, winType, skew){
      const targetFmax=200000; const neededOSR=Math.ceil((targetFmax*2)/sampleRate); const OSR=Math.max(2, Math.min(16, neededOSR));
      const hiSR=sampleRate*OSR; const MAX_HI_LEN=262144; const hiLen=Math.min(MAX_HI_LEN, Math.max(2048, fftLen*OSR));
      const inHi=genWave(type, f, A, hiSR, hiLen); const shapedHi=applyShaper(inHi, sh, drv, th, skew); const magsDBHi=spectrumDB(shapedHi, hiSR, winType);
      return { magsDB:magsDBHi, sampleRate: hiSR };
    }

    // ===== Controller =====
    function updateLabels(){
      els.freqVal.textContent = parseInt(els.freq.value,10);
      els.driveVal.textContent= parseFloat(els.drive.value).toFixed(1);
      els.clipVal.textContent = parseFloat(els.clip.value).toFixed(2);
      if (els.skewVal) els.skewVal.textContent = parseFloat(els.skew.value).toFixed(2);
      els.dbfloorVal.textContent = parseInt(els.dbfloor.value,10);
    }

    function render(){
      updateLabels();
      const sampleRate = SR_FIXED;
      const f = parseFloat(els.freq.value);
      const A = A_FIXED;
      const type = els.wave.value;

      const timeLen = Math.min(24000, Math.max(256, Math.round(CYCLES_DEFAULT * sampleRate / Math.max(f,1))));
      const fftLen = FFTLEN_DEFAULT;
      const winType = WINTYPE_DEFAULT;

      const inputTime = genWave(type, f, A, sampleRate, timeLen);
      const inputFFT  = genWave(type, f, A, sampleRate, fftLen);

      const sh = els.shaper.value; const drv = parseFloat(els.drive.value); const th = parseFloat(els.clip.value);
      const skew = els.skew ? parseFloat(els.skew.value) : 0;
      const shapedTime = applyShaper(inputTime, sh, drv, th, skew);
      const shapedFFT  = applyShaper(inputFFT,  sh, drv, th, skew);

      const scale = (arr)=>{ let m=0; for(let i=0;i<arr.length;i++) m=Math.max(m, Math.abs(arr[i])); const s=m>1?1/m:1; const out=new Float64Array(arr.length); for(let i=0;i<arr.length;i++) out[i]=arr[i]*s; return out; };
      const accent  = css.getPropertyValue('--accent');
      const accent2 = css.getPropertyValue('--accent-2');

      drawSignal(els.timeA, scale(inputTime), accent);
      drawSignal(els.timeB, scale(shapedTime), accent2);

      const magsDB = spectrumDB(shapedFFT, sampleRate, winType);
      const ideal  = computeIdealOverlay(sampleRate, fftLen, type, f, A, sh, drv, th, winType, skew);
      drawSpectrum(els.spec, magsDB, sampleRate, ideal);

      els.clipCtl.style.display = (sh === 'hard') ? '' : 'none';
      if (els.skewCtl) els.skewCtl.style.display = (sh === 'tanh_asym') ? '' : 'none';
    }

    function scaleCanvas(canvas){
      const ratio = window.devicePixelRatio || 1;
      const w = Math.round((canvas.clientWidth||canvas.width) * ratio);
      const h = Math.round((canvas.clientHeight||canvas.height) * ratio);
      if(canvas.width!==w || canvas.height!==h){ canvas.width=w; canvas.height=h; }
    }
    function resize(){ [els.timeA, els.timeB, els.spec].forEach(c=> c && scaleCanvas(c)); render(); }

    // Events (no amp/sr listeners anymore)
    ['input','change'].forEach(ev=>{
      [els.wave, els.freq, els.shaper, els.drive, els.clip, els.dbfloor, els.skew]
        .forEach(el=> el && el.addEventListener(ev, render));
    });
    window.addEventListener('resize', resize);

    // Boot
    resize();
  }
  function boot(){
    document.querySelectorAll('.kh-waveshaper').forEach(function(el){
      if(!el.dataset.khInit){ el.dataset.khInit='1'; init(el); }
    });
  }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', boot);
  else boot();
})();
</script>
