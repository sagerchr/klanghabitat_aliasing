<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Aliasing Demo — dBFS, Windowing</title>
<style>
    :root {
      --bg: #0b1020;
      --panel: #111827;
      --card: #1f2937;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --accent: #60a5fa;
      --accent2: #a78bfa;
      --warn: #fbbf24;
      --nyq: #ef4444;
      --grid: #334155;
    }

    html, body { margin:0; padding:0; background:var(--bg); color:var(--text); font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
    .wrap { padding: 16px; }
    h1 { margin: 0 0 6px; font-size: 24px; font-weight: 600; }
    .sub { color: var(--muted); margin-bottom: 16px; font-size: 14px; }
    .grid { display: grid; grid-template-columns: 2fr 1fr; gap: 12px; }
    .card { margin: 6px 6px 6px; background: var(--card); border: 1px solid #1f2937; border-radius: 12px; padding: 10px; }
    .card h2 { margin: 6px 6px 10px; font-size: 14px; font-weight: 600; color: var(--text); }
    canvas { width: 100%; height: 220px; background: black; border-radius: 10px; display:block; }
    .controls .row { margin-bottom: 14px; }
    label { font-size: 12px; display:block; margin-bottom: 4px; color: var(--text); }

    /* === Bigger selects & sliders === */
    select, input[type=range] { width: 100%; }

    /* Selects: taller and easier to hit */
    select {
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;

      background: var(--panel)
        url("data:image/svg+xml;utf8,<svg fill='%23e5e7eb' height='14' viewBox='0 0 20 20' width='14' xmlns='http://www.w3.org/2000/svg'><path d='M5.25 7.5l4.75 4.75 4.75-4.75' /></svg>")
        no-repeat right 12px center;
      background-size: 14px 14px;

      color: var(--text);
      border: 1px solid #374151;
      border-radius: 8px;

      height: 30px;
      padding: 6px 36px 6px 12px; /* extra space for arrow */
      font-size: 14px;
      line-height: 1;

      cursor: pointer;
      transition: background-color 0.2s ease, border-color 0.2s ease;
    }

    select:hover {
      background-color: #1e2533;
    }
    /* Range: reset native styles so we control height */
    input[type=range] {
      -webkit-appearance: none;
      appearance: none;
      background: transparent;   /* track styled below */
      border: none;
      height: 40px;              /* overall control height */
      padding: 0;
      margin: 0;
    }

    /* Track */
    input[type=range]::-webkit-slider-runnable-track {
      height: 8px;               /* thicker track */
      background: var(--grid);
      border-radius: 999px;
    }
    input[type=range]::-moz-range-track {
      height: 8px;
      background: var(--grid);
      border-radius: 999px;
    }

    /* Thumb */
    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;               /* bigger knob */
      height: 18px;
      border-radius: 50%;
      background: var(--accent);
      border: 2px solid #1f2937;
      margin-top: calc((8px - 18px) / 2); /* center on track */
    }
    input[type=range]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent);
      border: 2px solid #1f2937;
    }

    /* Focus ring for a11y */
    select:focus,
    input[type=range]:focus {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    /* Bigger checkbox (optional) */
    input[type=checkbox] {
      background: var(--panel);
      color: var(--text);
      border: 1px solid #374151;
      border-radius: 6px;
      transform: scale(1.2);
      accent-color: var(--accent);
    }

    .inline { display:flex; align-items:center; gap:8px; }
    .hint { font-size: 11px; color: var(--muted); }

    @media (max-width: 900px) {
      .grid { grid-template-columns: 1fr; }
    }
</style>
</head>
<body>
  <div class="wrap">
    <h1>klanghabitat Aliasing Demo</h1>
    <div class="sub" id="readout"></div>
    <div class="grid">
      <div class="left">
        <div class="card">
          <h2>Original (continuous) + sampled points</h2>
          <canvas id="c1"></canvas>
        </div>
        <div class="card">
          <h2>Reconstructed (ideal sinc) from sampled points</h2>
          <canvas id="c2"></canvas>
        </div>
        <div class="card">
          <h2>Magnitude Spectrum</h2>
          <canvas id="c3"></canvas>
        </div>
      </div>
      <div class="card controls">
        <h2>Controls</h2>
        <div class="row">
          <label for="wave">Waveform</label>
          <select id="wave">
            <option>Sine</option>
            <option>Square</option>
            <option>Triangle</option>
			<option>Sawtooth</option>
          </select>
        </div>
        <div class="row">
            <input id="freq" type="range" min="0" max="1" value="0.5" step="0.001" />
            <label for="freq">Frequency: <span id="freqLabel"></span></label>
            <div class="hint">Folded: <span id="foldedLabel"></span></div>
        </div>
        <div class="row">
          <label for="fs">Sample rate</label>
          <select id="fs">
            <option value="22050">22.05 kHz</option>
            <option value="32000">32 kHz</option>
            <option value="44100">44.1 kHz</option>
            <option value="48000" selected>48 kHz</option>
            <option value="88200">88.2 kHz</option>
            <option value="96000">96 kHz</option>
            <option value="176400">176.4 kHz</option>
            <option value="192000">192 kHz</option>
          </select>
        </div>
          <div class="row">
        <div class="hint">Tip: push the tone above Nyquist to watch it mirror. Use Square/Triangle to provoke dense aliasing from higher harmonics.</div>
      </div>
    </div>
  </div>
<script>
(function () {
  const els = {
    c1: document.getElementById('c1'),
    c2: document.getElementById('c2'),
    c3: document.getElementById('c3'),
    wave: document.getElementById('wave'),
    freq: document.getElementById('freq'),
    fs: document.getElementById('fs'),
    readout: document.getElementById('readout'),
    freqLabel: document.getElementById('freqLabel'),
    foldedLabel: document.getElementById('foldedLabel'),
  };

  // ======= Config =======
  const FREQ_MIN = 20;       // slider low end (Hz)
  const FREQ_MAX = 80000;    // slider high end (Hz)
  const FMAX_VIEW = 200000;  // spectrum right edge (Hz)
  const CURVE_COLOR = '#1e3a8a'; // dark blue for time-domain curves

  // Central palette for spectrum
  const COLORS = {
    background:   '#0b1020',
    grid:         '#334155',
    labels:       '#cbd5e1',

    nyquistLine:  '#ef4444',
    nyquistText:  '#cbd5e1',


    fundamentalMarker: '#93c5fd', // dashed marker at f0
    aliasMarker:       '#f59e0b', // dashed marker at alias(f0)



    fftCurve:     '#a78bfa',      // only if showFFT
    stemBelow:    '#f59e0b',      // ideal harmonics ≤ Nyquist
    stemAbove:    '#60a5fa',      // ideal harmonics > Nyquist
    aliasStem:    '#1e3a8a'       // darkblue reflections (folded to baseband)
  };
  // ======= Helpers =======
  function triangleWave(t) {
    const frac = t - Math.floor(t);
    return 2 * Math.abs(2 * frac - 1) - 1;
  }

  function fmtHz(v) {
    return v < 1000 ? `${Math.round(v)} Hz`
                    : `${(v / 1000).toFixed(v < 10000 ? 3 : 2)} kHz`;
  }

  function genWave(t, f0, amp, wave) {
    const out = new Float64Array(t.length);
    for (let i = 0; i < t.length; i++) {
      const phase = f0 * t[i];
      let v = 0;
      if (wave === 'Sine') v = Math.sin(2 * Math.PI * phase);
      else if (wave === 'Square') v = Math.sign(Math.sin(2 * Math.PI * phase));
	  else if (wave === 'Triangle') v = triangleWave(phase);
	  else  v = sawWave(phase);
      out[i] = amp * v;
    }
    return out;
  }

  function sawWave(t){
	// rising saw in [-1, 1]
	const frac = t - Math.floor(t);
	return 2*frac - 1;
  }
  
  function aliasFundamental(f, fs) {
    return Math.abs(f - fs * Math.round(f / fs));
  }

  function prepCanvas(canvas) {
    const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    const cssW = canvas.clientWidth || canvas.width;
    const cssH = canvas.clientHeight || canvas.height;
    if (canvas.width !== Math.floor(cssW * dpr) || canvas.height !== Math.floor(cssH * dpr)) {
      canvas.width = Math.floor(cssW * dpr);
      canvas.height = Math.floor(cssH * dpr);
    }
    const ctx = canvas.getContext('2d');
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    return { ctx, W: cssW, H: cssH };
  }

  function drawTime(canvas, t, x, points, opts = {}) {
    const { ctx, W, H } = prepCanvas(canvas);
    const { autoscale = false, headroom = 1.1 } = opts;

    ctx.clearRect(0, 0, W, H);
    ctx.fillStyle = COLORS.background;
    ctx.fillRect(0, 0, W, H);

    let peak = 1.0;
    if (autoscale) {
      peak = 1e-9;
      for (let i = 0; i < x.length; i++) {
        const a = Math.abs(x[i]);
        if (a > peak) peak = a;
      }
      peak *= headroom;
    }
    const yScale = (H * 0.45) / peak;

    // midline
    ctx.strokeStyle = COLORS.grid;
    ctx.globalAlpha = 0.7;
    ctx.beginPath(); ctx.moveTo(0, H / 2); ctx.lineTo(W, H / 2); ctx.stroke();
    ctx.globalAlpha = 1;

    // curve
    ctx.strokeStyle = CURVE_COLOR;
    ctx.lineWidth = 2;
    ctx.beginPath();
    const xmin = t[0], xmax = t[t.length - 1];
    for (let i = 0; i < t.length; i++) {
      const xPix = ((t[i] - xmin) / (xmax - xmin)) * (W - 1);
      const yPix = H / 2 - x[i] * yScale;
      if (i === 0) ctx.moveTo(xPix, yPix); else ctx.lineTo(xPix, yPix);
    }
    ctx.stroke();

    // points (sample dots)
    if (points) {
      ctx.fillStyle = '#fbbf24';
      const tS = points.tS, xS = points.xS;
      for (let i = 0; i < tS.length; i++) {
        const tt = tS[i]; if (tt < xmin || tt > xmax) continue;
        const xPix = ((tt - xmin) / (xmax - xmin)) * (W - 1);
        const yPix = H / 2 - xS[i] * yScale;
        ctx.beginPath(); ctx.arc(xPix, yPix, 3, 0, Math.PI * 2); ctx.fill();
      }
    }
  }

	function genHarmonics(wave, f0, amp, fmax){
	  const stems = [];
	  if (f0 <= 0) return stems;

	  if (wave === 'Sine') {
		if (f0 <= fmax) stems.push({ f: f0, a: amp });
		return stems;
	  }

	  if (wave === 'Square') {
		const norm = 4 / Math.PI;            // |H_n| = 4/(π n), odd n
		for (let n = 1; ; n += 2){
		  const f = n * f0; if (f > fmax) break;
		  stems.push({ f, a: amp * (norm * (1/n)) });
		}
		return stems;
	  }

	  if (wave === 'Triangle') {
		const norm = 8 / (Math.PI * Math.PI); // |H_n| = 8/(π² n²), odd n
		for (let n = 1; ; n += 2){
		  const f = n * f0; if (f > fmax) break;
		  stems.push({ f, a: amp * (norm * (1/(n*n))) });
		}
		return stems;
	  }

	  // Sawtooth: all harmonics, |H_n| = 2/(π n)
	  const norm = 2 / Math.PI;
	  for (let n = 1; ; n++){
		const f = n * f0; if (f > fmax) break;
		stems.push({ f, a: amp * (norm * (1/n)) });
	  }
	  return stems;
	}

  // ======= Spectrum (no FFT) =======
  function drawSpectrum(canvas, fs, f0, wave, amp, opts = {}) {
    const {
      dbFloor = -60,             // bottom of the dB axis
      fmin = 10,                 // left edge
      fmax = FMAX_VIEW,          // right edge
    } = opts;

    const { ctx, W, H } = prepCanvas(canvas);

    // mappers
    const a = Math.log10(fmin), b = Math.log10(fmax);
    const logX = (f) => {
      const t = (Math.log10(Math.max(f, fmin)) - a) / (b - a);
      return Math.min(W - 1, Math.max(0, t * (W - 1)));
    };
    const dbToY = (dB) => {
      const clamped = Math.max(dbFloor, Math.min(0, dB));
      return H - ((clamped - dbFloor) / (0 - dbFloor)) * H;
    };

    // background
    ctx.clearRect(0, 0, W, H);
    ctx.fillStyle = COLORS.background;
    ctx.fillRect(0,0,W,H);

    // ---- grids ----
    const dbTicks   = [-140,-120,-100,-80,-60,-40,-20,0];
    const freqTicks = [10,20,30,40,50,60,70,80,90,
                       100,200,300,400,500,600,800,900,
                       1000,2000,3000,4000,5000,6000,7000,8000,9000,
                       10000,20000,30000,40000,50000,600000,700000,80000,900000,
					   100000,200000];
					   
    const majorFreqTicks = [100, 1000, 10000, 100000];
    const majorSet = new Set(majorFreqTicks);

    // horizontal dB
    ctx.strokeStyle = COLORS.grid; ctx.lineWidth = 1; ctx.globalAlpha = 0.6;
    ctx.beginPath();
    for (const d of dbTicks) { const y = dbToY(d); ctx.moveTo(0, y); ctx.lineTo(W, y); }
    ctx.stroke();
    ctx.globalAlpha = 1;

    // vertical (minor)
    ctx.save();
    ctx.strokeStyle = COLORS.grid; ctx.globalAlpha = 0.35; ctx.lineWidth = 1;
    ctx.beginPath();
    for (const f of freqTicks) {
      if (f < fmin || f > fmax || majorSet.has(f)) continue;
      const x = logX(f);
      ctx.moveTo(x, 0); ctx.lineTo(x, H);
    }
    ctx.stroke();
    ctx.restore();

    // vertical (major)
    ctx.save();
    ctx.strokeStyle = COLORS.grid; ctx.globalAlpha = 0.8; ctx.lineWidth = 1.5;
    ctx.beginPath();
    for (const f of majorFreqTicks) {
      if (f < fmin || f > fmax) continue;
      const x = logX(f);
      ctx.moveTo(x, 0); ctx.lineTo(x, H);
    }
    ctx.stroke();
    ctx.restore();

    // Nyquist
    const nyq = fs / 2;
    const nx = logX(nyq);
    ctx.setLineDash([6, 6]);
    ctx.strokeStyle = COLORS.nyquistLine;
    ctx.beginPath(); ctx.moveTo(nx, 0); ctx.lineTo(nx, H); ctx.stroke();
    ctx.setLineDash([]);

    // f0 & its alias markers (dashed)
    const aliasF0 = aliasFundamental(f0, fs);
    const x0 = logX(Math.min(Math.max(f0, fmin), fmax));
    const xa = logX(Math.min(Math.max(aliasF0, fmin), fmax));

    ctx.setLineDash([2, 4]); ctx.strokeStyle = COLORS.fundamentalMarker;
    ctx.beginPath(); ctx.moveTo(x0, 0); ctx.lineTo(x0, H); ctx.stroke();

    ctx.setLineDash([4, 4]); ctx.strokeStyle = COLORS.aliasMarker;
    ctx.beginPath(); ctx.moveTo(xa, 0); ctx.lineTo(xa, H); ctx.stroke();
    ctx.setLineDash([]);

    // Ideal harmonic stems
    const stems = genHarmonics(wave, f0, amp, fmax);

    // Originals (green/orange)
    ctx.lineWidth = 1.5;
    for (const { f, a: ampl } of stems) {
      if (f < fmin || f > fmax) continue;
      const x = logX(f);
      const y = dbToY(20 * Math.log10(Math.max(ampl, 1e-12)));
      ctx.strokeStyle = (f <= nyq) ? COLORS.stemBelow : COLORS.stemAbove;
      ctx.beginPath(); ctx.moveTo(x, H - 1); ctx.lineTo(x, y); ctx.stroke();
    }

    // Red reflections (aliases)
    for (const { f, a: ampl } of stems) {
      if (f <= nyq) continue; // only mirror those above Nyquist
      const fa = Math.abs(f - fs * Math.round(f / fs));
      if (fa < fmin || fa > fmax) continue;
      const xA = logX(fa);
      const yA = dbToY(20 * Math.log10(Math.max(ampl, 1e-12)));
      ctx.strokeStyle = COLORS.aliasStem;
      ctx.beginPath(); ctx.moveTo(xA, H - 1); ctx.lineTo(xA, yA); ctx.stroke();
    }

    // X labels (majors only)
    ctx.fillStyle = COLORS.labels;
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, monospace';
    ctx.textAlign = 'center'; ctx.textBaseline = 'top';
    for (const f of majorFreqTicks) {
      if (f < fmin || f > fmax) continue;
      const x = logX(f);
      const label = (f >= 1000) ? `${(f / 1000).toFixed(0)} kHz` : `${f} Hz`;
      ctx.fillText(label, x, H - 14);
    }

    // Top-right: Nyquist
    ctx.textAlign = 'right'; ctx.textBaseline = 'top';
    ctx.fillStyle = COLORS.nyquistText;
    ctx.fillText(`${(nyq / 1000).toFixed(1)} kHz (Nyquist)`, W - 6, 6);
  }

  // ======= Render loop (no FFT) =======
  function render() {
    // 0..1 slider → log Hz
    const sliderVal = parseFloat(els.freq.value);
    const f0 = FREQ_MIN * Math.pow(FREQ_MAX / FREQ_MIN, sliderVal);

    const fs = +els.fs.value;
    const wave = els.wave.value;
    const nyq = fs / 2;
    const amp = 1.0;

    // Labels
    els.freqLabel.textContent = fmtHz(f0);
    els.foldedLabel.textContent = fmtHz(aliasFundamental(f0, fs));
    els.readout.textContent =
      `Fs: ${(fs / 1000).toFixed(1)} kHz · Nyquist: ${(nyq / 1000).toFixed(1)} kHz`;

    // Time windows
    const cycles = 3;
    const viewWindow = Math.max(1e-6, cycles / Math.max(f0, 1e-9)); // show ~3 cycles
    const viewCount = 1600;
    const tView = new Float64Array(viewCount);
    for (let i = 0; i < viewCount; i++) tView[i] = i * (viewWindow / (viewCount - 1));
    const xCont = genWave(tView, f0, amp, wave);

    // Sampled signal (use enough samples to cover the view + ±5T for sinc)
    const T = 1 / fs;
    const left = -5 * T, right = viewWindow + 5 * T;
    const nSamp = Math.max(64, Math.ceil((right - left) * fs));
    const tSamp = new Float64Array(nSamp);
    for (let n = 0; n < nSamp; n++) tSamp[n] = left + n / fs;
    const xSamp = genWave(tSamp, f0, amp, wave);

    // Sinc reconstruction around the view
    const xRecon = (function sincRecon(samples, tS, tR) {
      const T = tS[1] - tS[0];
      const y = new Float64Array(tR.length);
      for (let i = 0; i < tS.length; i++) {
        const si = samples[i];
        for (let j = 0; j < tR.length; j++) {
          const u = (tR[j] - tS[i]) / T;
          y[j] += si * (u === 0 ? 1 : Math.sin(Math.PI * u) / (Math.PI * u));
        }
      }
      return y;
    })(xSamp, tSamp, tView);

    // Draw
    drawTime(els.c1, tView, xCont, { tS: tSamp, xS: xSamp });
    drawTime(els.c2, tView, xRecon, { tS: tSamp, xS: xSamp }, { autoscale: true });
    drawSpectrum(els.c3, fs, f0, wave, amp);
  }

  // Inputs
  ['input', 'change'].forEach(evt => {
    [els.wave, els.freq, els.fs].forEach(el => el.addEventListener(evt, render));
  });
  window.addEventListener('resize', render);

  render();
})();
</script>
</body>
</html>
